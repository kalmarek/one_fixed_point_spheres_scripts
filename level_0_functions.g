# To load this file from the project directory (assuming GAP is launched in this directory), call
# Read( Filename( [DirectoryCurrent()], "level_0_functions.g" ) );


# Let chi be the irreducible character of a group G (that is, the element of Irr(G)).
# The function below computes the Frobenius-Schur indicator of chi.
FrobeniusSchurIndicator := function( chi, G )
	local result, cl, repr;
	result := 0;
	for cl in ConjugacyClasses( G ) do
		repr := Representative( cl );
		result := result+Size( cl )*( repr*repr )^chi;
	od;
	result := result/Order( G );
	return result;
end;

# Let S1 and S2 be the subsets of a group G.
# The function below computes the subgroup of G generated by elements from the union of S1 and S2.
GroupByGeneratingSubsets := function( S1, S2 )
	local result, h, set;
	set := [];
	for h in S1 do
		Add( set, h );
	od;
	for h in S2 do
		Add( set, h );
	od;
	result := GroupByGenerators( set );
	return result;
end;

# Let N be a normal subgroup of G.
# The function below computes the quotient group G/N.
QuotientGroup := function( G, N )
	return Image( NaturalHomomorphismByNormalSubgroup( G, N ) );
end;

# Let G be a group and realModule be a list of pairs representing characters of a given real G-module:
# - the first coordinate of the i-th pair is the list of characters evaluated on conjugacy classes of G
#   of the i-th irreducible real G-module,
# - the second coordinate of the i-th pair is the number of copies of the i-th irreducible real G-module
#   which occur in realModule.
# The function below computes the list of characters of realModule evaluated on conjugacy classes of G.
RealModuleCharacters := function( realModule, G )
	local irrComponent, result, temp, cl, g, i;
	result := [];
	for i in [1..Size( ConjugacyClasses( G ) )] do
		temp := 0;
		for irrComponent in realModule do
			temp := temp+irrComponent[1][i]*irrComponent[2];
		od;
		Add( result, temp );
	od;
	return result;
end;

# Let 'restrictions' be a list of length n of positive integers.
# The function below computes the list of tuples t[1..n] such that
# t[i] <= restrictions[i] for 1<=i<=n.
RestrictedTuples := function( restrictions )
	local result, tuple, finalTuple, res, coord, value, i, temp, tuple2;
	finalTuple := [];
	tuple := [];
	coord := Size( restrictions );
	value := 1;
	result := [];
	for res in restrictions do
		Add( finalTuple, res );
		Add( tuple, 1 );
	od;
	temp := 1;
	while tuple <> finalTuple and temp < 100 do
		tuple2 := [];
		for i in [1..Size( restrictions )] do
			Add( tuple2, tuple[i] );
		od;
		Add( result, tuple2 );
		while tuple[coord]+1 > restrictions[coord] do
			coord := coord-1;
		od;
		tuple[coord] := tuple[coord]+1;
		for i in [(coord+1)..Size(restrictions)] do
			tuple[i] := 1;
		od;
		coord := Size( restrictions );
		temp := temp+1;
	od;
	Add( result, finalTuple );
	return result;
end;

# Checks whether the group G satisifes the assumptions of Proposition 2.9 from [1].
SatisfiesProposition29 := function( G )
	local g, cl;
	for cl in ConjugacyClasses( G ) do
		g := Representative( cl );
		if (IsPrimePowerInt( Order( g ) ) = false and Order( g ) <> 1) or
			 (IsPrimePowerInt( Order( g ) ) = true and (Order( g ) mod 2) = 0 and Order( g ) > 4) then
			 return false;
		fi;
	od;
	return true;
end;
